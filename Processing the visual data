def zoom(image):
  zoom = iaa.Affine(scale=(1, 1.3)) #zooming up to 30% of image
  image = zoom.augment_image(image)
  return image

def pan(image):
  pan = iaa.Affine(translate_percent={"x": (-0.1,0.1), "y": (0.1,0.1)})
  image = pan.augment_image(image)
  return image
  
def img_random_brightness(image):
  brightness = iaa.Multiply((0.2, 1.2)) #darker images are more effective in comparison to more bright ones
  image = brightness.augment_image(image)
  return image
  
def img_random_flip(image, steering_angle):
  image = cv2.flip(image, 1) # 1 means horizontal flip
  steering_angle = -steering_angle
  return image, steering_angle
  
def random_augment(image, steering_angle):
  image = mpimg.imread(image)
  if np.random.rand() < 0.5:
    #each augmentation will be applied only 50%
    image = pan(image)
  if np.random.rand() < 0.5:
    #each augmentation will be applied only 50%
    image = zoom(image)
  if np.random.rand() < 0.5:
    #each augmentation will be applied only 50%
    image = img_random_brightness(image)
  if np.random.rand() < 0.5:
    #each augmentation will be applied only 50%
    image, steering_angle = img_random_flip(image, steering_angle)
  return image, steering_angle
  
number_of_columns = 2
number_of_rows = 10
fig, axs = plt.subplots(number_of_rows, number_of_columns, figsize=(15,50))
fig.tight_layout()

for i in range(10):
  randnum = random.randint(0, len(image_paths)-1)
  random_image = image_paths[randnum]
  random_steering = steerings[randnum]

  original_image = mpimg.imread(random_image)
  augmented_image, steering = random_augment(random_image, random_steering)

  axs[i][0].imshow(original_image)
  axs[i][0].set_title('Original Image')
  axs[i][1].imshow(augmented_image)
  axs[i][1].set_title ('Augmented Image')
  
def img_preprocess(img):
  # cropping unnecessary part of image
  img = img[60:135,:,:] # height,width,channel
  img = cv2.cvtColor(img,cv2.COLOR_RGB2YUV) # yuv format due to nvidia arch.
  img = cv2.GaussianBlur(img,(3,3),0) #reducing noise w/GaussianBlur
  img = cv2.resize(img,(200,66)) #for nvidia model arch.
  img = img/255 #normalizing the variables
  return img
  
image = image_paths[100] # choosing a random image to check the effects of preprocessing
original_image = mpimg.imread(image)
preprocessed_image = img_preprocess(original_image)

fig, axs = plt.subplots(1,2,figsize=(15, 10))
fig.tight_layout()

axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[1].imshow(preprocessed_image)
axs[1].set_title('Preprocessed Image')  

def batch_generator(image_paths, steering_ang, batch_size, istraining):
  #validation data should not be augmented
  #istraining will be 1 when training data is fed and 0 when valid data is fed
  while True:
    batch_img = []
    batch_steering = []
    
    for i in range(batch_size):
      random_index = random.randint(0, len(image_paths)-1)
      if istraining:
        im, steering = random_augment(image_paths[random_index], steering_ang[random_index])
      else:
        im = mpimg.imread(image_paths[random_index])
        steering = steering_ang[random_index]

      im = img_preprocess(im)
      batch_img.append(im)
      batch_steering.append(steering)
    yield (np.asarray(batch_img), np.asarray(batch_steering))
    
    X_train_gen, y_train_gen = next(batch_generator(X_train, y_train, 1, 1))
X_valid_gen, y_valid_gen = next(batch_generator(X_valid, y_valid, 1, 0))

fig, axs = plt.subplots(1, 2, figsize=(15, 10))
fig.tight_layout()

axs[0].imshow(X_train_gen[0])
axs[0].set_title('Training Image')
axs[1].imshow(X_valid_gen[0])
axs[1].set_title('Validation Image')
